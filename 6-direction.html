<html>
  <head>
    <meta charset="utf-8" />
    <style>
      * {
        user-select: none;
      }
      body {
        margin: 0;
        padding: 0;
        overscroll-behavior-x: none;
        overscroll-behavior-y: none;
      }
      #contents {
        display: flex;
        align-items: flex-start;
        margin: 10px;
      }
      .wrapper {
        position: relative;
        box-sizing: border-box;
        border: solid 1px #aaaaaa;
        margin: 0 10px 10px 0;
        display: flex;
        align-items: center;
        overflow: hidden;
      }
      .wrapper canvas {
        position: absolute;
        top: 0;
        left: 0;
      }
      #display-wrapper {
        grid-column: 1;
        grid-row: 1;
      }
      #score-wrpper {
        grid-column: 1;
        grid-row: 2;
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 5px;
      }
      #failed-dialog {
        display: none;
        position: absolute;
        margin: 150px 10px;
        justify-content: center;
        align-items: center;
        width: calc(100% - 20px);
        height: calc(100% - 300px);
        background-color: #ffffffcc;
        border: solid 1px #aaaaccee;
      }
      #form {
        margin-right: 10px;
        width: 300px;
        padding: 5px 5px 0 5px;
        border: solid 1px #aaaaaa;
        box-sizing: border-box;
        font-size: 12px;
      }
      #form .row {
        list-style: none;
        margin: 0 0 5px 0;
        padding: 5px;
        background-color: #eeeeff;
      }
      #form .row .operator {
        display: flex;
        align-items: center;
      }
      #form .row .input {
        margin-right: 5px;
        width: 50px;
      }
      .meter {
        position: relative;
        height: 24px;
        margin-top: 5px;
      }
      .meter::before {
        content: "";
        position: absolute;
        display: block;
        width: 100%;
        height: 1px;
        top: 50%;
        border-top: solid 1px #aaaaaa;
      }
      .meter-handle {
        position: absolute;
        top: 0;
        width: 10px;
        height: calc(100% - 2px);
        border: solid 1px #888888;
        background-color: #ffffff;
      }
      #color-mode-wrapper {
        display: flex;
      }
    </style>
  </head>
  <body>
    <div id="contents">
      <form id="form">
        <div class="row">
          <div class="operator">
            <span class="title">中心点距離</span>：<span class="announcer" id="focal-length-announcer"></span>
          </div>
          <div class="meter" id="focal-length-meter">
            <div class="meter-handle" id="focal-length-meter-handle"></div>
          </div>
        </div>
        <div class="row">
          <div class="operator">
            <span class="title">ブロック不透明度</span>：<span class="announcer" id="color-alpha-announcer"></span>%
          </div>
          <div class="meter" id="color-alpha-meter">
            <div class="meter-handle" id="color-alpha-meter-handle"></div>
          </div>
        </div>
        <div class="row" id="color-mode-wrapper">
          <div class="operator">
            <span class="title">層色分け</span>：
          </div>
          <input type="radio" name="color-mode" id="color-mode-1" checked /><label for="color-mode-1">あり</label>
          <input type="radio" name="color-mode" id="color-mode-2" /><label for="color-mode-2">なし</label>
        </div>
      </form>
      <div id="display-score-wrapper">
        <div class="wrapper canvas-wrapper" id="display-wrapper">
          <canvas class="canvas" id="display"></canvas>
          <div id="failed-dialog">
            残念です。
          </div>
        </div>
        <div class="wrapper" id="score-wrpper">
          <div>得点：</div>
          <div id="score-display">0</div>
        </div>
      </div>
    </div>
    <script>
      const R = 150;
      const capacity = 10;
      const displaySize = 500;
      const displayRadius = displaySize / 2;
      const vectorSlideRadius = displaySize / 8 * 3;
      const blockFormations = [
        { P: [[0, 0], [0, -1], [0, 1], [0, 2]], C: [255, 0, 0] },
        { P: [[0, 0], [0, -1], [-1, -1], [0, 1]], C: [0, 128, 255] },
        { P: [[0, 0], [0, -1], [-1, 1], [0, 1]], C: [255, 255, 0] },
        { P: [[0, 0], [-1, 0], [0, 1], [1, 1]], C: [0, 170, 0] },
        { P: [[0, 0], [1, 0], [0, 1], [1, -1]], C: [128, 0, 170] },
        { P: [[0, 0], [-1, 0], [1, 0], [0, 1]], C: [255, 80, 170] },
        { P: [[0, 0], [1, 0], [0, 1], [1, 1]], C: [0, 0, 255] },
      ];
      const keyMap = {
        ArrowUp: 'U',
        ArrowRight: 'R',
        ArrowDown: 'D',
        ArrowLeft: 'L',
        KeyZ: [1, 0, 0],
        KeyA: [3, 0, 0],
        KeyX: [0, 1, 0],
        KeyS: [0, 3, 0],
        KeyC: [0, 0, 1],
        KeyD: [0, 0, 3],
      };
      const directionMap = { U: 0, R: 1, D: 2, L: 3 };
      const vectorMap = [
        ['X', 'Y', 'Z', capacity, -1],
        ['X', 'Z', 'Y', capacity, -1],
        ['X', 'Y', 'Z', capacity * -1, 1],
        ['X', 'Z', 'Y', capacity * -1, 1],
        ['Y', 'Z', 'X', capacity, -1],
        ['Y', 'Z', 'X', capacity * -1, 1],
      ];
      const colorMap = [
        [200, 255, 248],
        [255, 200, 0],
        [255, 80, 120],
        [80, 80, 255],
        [0, 200, 100],
        [200, 40, 184],
        [255, 120, 20],
        [40, 200, 255],
        [200, 200, 200],
        [60, 60, 60],
        [255, 0, 0],
        [0, 255, 0],
        [0, 0, 255],
      ];
      const phaseTimes = {
        set: 25,
        fall: 2000,
        vanish: 15,
        strip: 15,
      };

      const display = document.getElementById('display');
      const displayWrapper = document.getElementById('display-wrapper');
      const displayContext = display.getContext('2d');
      const scoreDisplay = document.getElementById('score-display');
      const failedDialog = document.getElementById('failed-dialog');
      const colorModeInput1= document.getElementById('color-mode-1');
      const colorModeInput2 = document.getElementById('color-mode-2');
      display.style.width = `${displaySize}px`;
      display.setAttribute('width', displaySize);
      display.setAttribute('height', displaySize);
      displayWrapper.style.height = `${displaySize}px`;
      Array.prototype.forEach.call(document.getElementsByClassName('wrapper'), (elem) => {
        elem.style.width = `${displaySize}px`;
      });

      let focalLengthPercentage = 2;
      let moveSwitch = false;
      let rotationSwitch = false;
      let latestMoveX = 0;
      let latestMoveY = 0;
      let latestBaseX = 0;
      let latestBaseY = 0;
      let latestPointerX = 0;
      let latestPointerY = 0;
      let moveType = 'vector';
      let animation = null;
      let animationSwitch = false;
      let phase = 'set';
      let blocks = [{ P: { X:  0, Y:  0, Z:  0 }, C: [200, 255, 248] }];
      // let blocks = [
      //   { P: { X:  0, Y:  0, Z:  0 }, C: [200, 255, 248] },
      //   { P: { X:  1, Y:  1, Z:  1 }, C: [255, 200,   0] },
      //   { P: { X:  1, Y:  0, Z:  1 }, C: [255, 200,   0] },
      //   { P: { X:  1, Y:  0, Z:  0 }, C: [255, 200,   0] },
      //   { P: { X:  1, Y:  1, Z:  0 }, C: [255, 200,   0] },
      //   { P: { X:  0, Y:  1, Z:  1 }, C: [200, 100, 200] },
      //   { P: { X:  0, Y:  0, Z:  1 }, C: [200, 100, 200] },
      //   { P: { X: -1, Y:  0, Z:  1 }, C: [200, 100, 200] },
      //   { P: { X: -1, Y:  1, Z:  1 }, C: [200, 100, 200] },
      //   { P: { X:  1, Y: -1, Z:  1 }, C: [100, 200, 200] },
      //   { P: { X:  1, Y: -1, Z:  0 }, C: [100, 200, 200] },
      //   { P: { X:  0, Y: -1, Z:  0 }, C: [100, 200, 200] },
      //   { P: { X:  0, Y: -1, Z:  1 }, C: [100, 200, 200] },
      //   { P: { X: -1, Y: -1, Z:  1 }, C: [255,  80, 120] },
      //   { P: { X: -1, Y: -1, Z:  0 }, C: [255,  80, 120] },
      //   { P: { X: -1, Y:  0, Z:  0 }, C: [255,  80, 120] },
      //   { P: { X: -1, Y: -1, Z: -1 }, C: [255,  80, 120] },
      //   { P: { X:  0, Y:  0, Z: -1 }, C: [ 80,  80, 255] },
      //   { P: { X:  0, Y: -1, Z: -1 }, C: [ 80,  80, 255] },
      //   { P: { X: -1, Y:  0, Z: -1 }, C: [ 80,  80, 255] },
      //   { P: { X: -1, Y:  1, Z: -1 }, C: [ 80,  80, 255] },
      //   { P: { X:  0, Y:  1, Z:  0 }, C: [160, 160, 160] },
      //   { P: { X:  0, Y:  1, Z: -1 }, C: [160, 160, 160] },
      //   { P: { X: -1, Y:  1, Z:  0 }, C: [160, 160, 160] },
      //   { P: { X:  1, Y:  1, Z: -1 }, C: [160, 160, 160] },
      //   { P: { X:  0, Y: -2, Z:  0 }, C: [255, 120,   0] },
      //   { P: { X:  0, Y: -2, Z: -1 }, C: [255, 120,   0] },
      //   { P: { X: -1, Y: -2, Z:  0 }, C: [255, 120,   0] },
      //   { P: { X: -1, Y: -2, Z: -1 }, C: [255, 120,   0] },
      //   { P: { X:  0, Y:  0, Z: -2 }, C: [  0, 200, 100] },
      //   { P: { X:  0, Y: -1, Z: -2 }, C: [  0, 200, 100] },
      //   { P: { X: -1, Y:  0, Z: -2 }, C: [  0, 200, 100] },
      //   { P: { X: -1, Y: -1, Z: -2 }, C: [  0, 200, 100] },
      //   { P: { X:  2, Y:  0, Z:  0 }, C: [200,   0, 100] },
      //   { P: { X:  2, Y: -1, Z:  0 }, C: [200,   0, 100] },
      //   { P: { X:  2, Y:  0, Z:  1 }, C: [200,   0, 100] },
      //   { P: { X:  2, Y: -1, Z:  1 }, C: [200,   0, 100] },
      // ];
      let block = null;
      let direction = 0;
      let fallingParams = null;
      let fallingBlocks = [];
      let vanishingBlocks = [];
      let meterSwitch = false;
      let meterHandleDiffX = 0;
      // 位置軸: 静止状態の対象物の基本姿勢からの傾きを表す軸
      let positionAxisX = Math.PI / 180 * 40; // 位置軸のZ軸(正面方向軸)に対する角度(0 ~ π)
      let positionAxisY = Math.PI / 180 * -50; // 位置軸のY軸(上下方向軸)に対する角度(-π ~ π)
      let positionAxisL = Math.PI / 180 * 50; // 位置軸に対する回転角度(-π ~ π)
      // 回転軸: 自転するベースとなる軸
      let momentAxisX = 0; // 位置軸のZ軸(正面方向軸)に対する角度(0 ~ π)
      let momentAxisY = 0; // 位置軸のY軸(上下方向軸)に対する角度(-π ~ π)
      let momentAxisL = 0; // 位置軸に対する回転角度(-π ~ π)
      let diffAxisL = 0;
      let axisX = positionAxisX;
      let axisY = positionAxisY;
      let axisL = positionAxisL;
      let lightX = Math.PI / 180 * 70; // 光源軸のZ軸(正面方向軸)に対する角度(0 ~ π)
      let lightY = Math.PI / 180 * 60; // 光源軸のY軸(上下方向軸)に対する角度(-π ~ π)
      let time = 0;
      let nextTime = 0;
      let phaseTime = 0;
      let score = 0;
      let colorAlpha1 = 187;
      let colorAlpha2 = 204;
      let colorMode = 'agate';

      const calculateBlockPosition = (pos, considerFocalLength) => {
        const RZ0 = Math.pow(pos.X * pos.X + pos.Y * pos.Y, 1 / 2); // Z面上の半径
        const TZ0 = RZ0 > 0 ? (Math.acos(pos.Y / RZ0) * (pos.X > 0 ? 1 : -1)) : 0;
        const TZ1 = TZ0 + axisL; // 回転角度の加算
        const LX1 = Math.sin(TZ1) * RZ0; // 回転軸に対するX軸上の相対距離
        const LY1 = Math.cos(TZ1) * RZ0; // 回転軸に対するY軸上の相対距離
        const RX1 = Math.pow(LY1 * LY1 + pos.Z * pos.Z, 1 / 2);
        const TX1 = RX1 > 0 ? (Math.acos(pos.Z / RX1) * (LY1 >= 0 ? 1 : -1)) : 0;
        const TX2 = TX1 + axisX;
        const LY2 = Math.sin(TX2) * RX1;
        const LZ2 = Math.cos(TX2) * RX1;
        const RZ2 = Math.pow(LX1 * LX1 + LY2 * LY2, 1 / 2);
        const TZ2 = RZ2 > 0 ? (Math.acos(LY2 / RZ2) * (LX1 > 0 ? 1 : -1)) : 0;
        const TZ3 = TZ2 + axisY;
        const LX3 = Math.sin(TZ3) * RZ2;
        const LY3 = Math.cos(TZ3) * RZ2;

        let X = LX3 / capacity * R;
        let Y = LY3 / capacity * R;
        let Z = LZ2 / capacity * R;

        if (considerFocalLength) {
          const focalLength = displaySize * focalLengthPercentage;
          const focalCofficient = 1 / Math.abs((focalLength - Z) / focalLength);
          [X, Y] = [X * focalCofficient, Y * focalCofficient];
        }

        return { X, Y, Z };
      };

      const calculateRelativeVector = (basePos, meshPos) => {
        const LRZ = Math.sin(lightX);
        const LLZ = Math.cos(lightX);
        const LLX = Math.sin(lightY) * LRZ;
        const LLY = Math.cos(lightY) * LRZ;
        const LRX = Math.pow(LLY * LLY + LLZ * LLZ, 1 / 2);
        const LRY = Math.pow(LLX * LLX + LLZ * LLZ, 1 / 2);
        const LTX = LRX > 0 ? (Math.acos(LLZ / LRX) * (LLY > 0 ? 1 : -1)) : 0;
        const LTY = LRY > 0 ? (Math.acos(LLZ / LRY) * (LLX > 0 ? 1 : -1)) : 0;

        const MLX0 = meshPos.X - basePos.X;
        const MLY0 = meshPos.Y - basePos.Y;
        const MLZ0 = meshPos.Z - basePos.Z;
        const MRX0 = Math.pow(MLY0 * MLY0 + MLZ0 * MLZ0, 1 / 2);
        const MTX0 = MRX0 > 0 ? (Math.acos(MLZ0 / MRX0) * (MLY0 > 0 ? 1 : -1)) : 0;
        const MTX1 = MTX0 + LTX;
        const MLZ1 = Math.cos(MTX1) * MRX0;
        const MLY1 = Math.sin(MTX1) * MRX0;
        const MRY1 = Math.pow(MLX0 * MLX0 + MLZ1 * MLZ1, 1 / 2);
        const MTY1 = MRY1 > 0 ? (Math.acos(MLZ1 / MRY1) * (MLX0 > 0 ? 1 : -1)) : 0;
        const MTY2 = MTY1 + LTY;
        const MLX2 = Math.sin(MTY2) * MRY1;
        const MLZ2 = Math.cos(MTY2) * MRY1;
        const MRZ2 = Math.pow(MLX2 * MLX2 + MLY1 * MLY1, 1 / 2);
        const MRO2 = Math.pow(MLZ2 * MLZ2 + MRZ2 * MRZ2, 1 / 2);
        const MTO2 = MRO2 > 0 ? Math.acos(MLZ2 / MRO2) : 0;

        return Math.abs(MTO2) % (Math.PI * 2);
      };

      const calculateColor = (C, V) => {
        const CD = C.map((C0, i) => {
          const C1 = V < 1 / 2
            ? Math.round(C0 + (255 - C0) * (1 - V * 2))
            : Math.round(C0 * (1 / 2 + 1 - V));

          return (C1 < 16 ? '0' : '') + C1.toString(16);
        });

        return `#${CD.join('')}`;
      };

      const calculateBlockIntervals = () => {
        const blockBase = block.P.reduce(
          (res, P) =>
            (direction === 0 && (!(`${P.X}.${P.Y}` in res) || res[`${P.X}.${P.Y}`].V > P.Z)) ? ({ ...res, [`${P.X}.${P.Y}`]: { P, V: P.Z }}) :
            (direction === 1 && (!(`${P.X}.${P.Z}` in res) || res[`${P.X}.${P.Z}`].V > P.Y)) ? ({ ...res, [`${P.X}.${P.Z}`]: { P, V: P.Y }}) :
            (direction === 2 && (!(`${P.X}.${P.Y}` in res) || res[`${P.X}.${P.Y}`].V < P.Z)) ? ({ ...res, [`${P.X}.${P.Y}`]: { P, V: P.Z }}) :
            (direction === 3 && (!(`${P.X}.${P.Z}` in res) || res[`${P.X}.${P.Z}`].V < P.Y)) ? ({ ...res, [`${P.X}.${P.Z}`]: { P, V: P.Y }}) :
            (direction === 4 && (!(`${P.Y}.${P.Z}` in res) || res[`${P.Y}.${P.Z}`].V > P.X)) ? ({ ...res, [`${P.Y}.${P.Z}`]: { P, V: P.X }}) :
            (direction === 5 && (!(`${P.Y}.${P.Z}` in res) || res[`${P.Y}.${P.Z}`].V < P.X)) ? ({ ...res, [`${P.Y}.${P.Z}`]: { P, V: P.X }}) :
            res,
          {}
        );
        const blocksCover = blocks.reduce(
          (res, { P }) =>
            (direction === 0 && blockBase[`${P.X}.${P.Y}`] && blockBase[`${P.X}.${P.Y}`].V > P.Z && (!(`${P.X}.${P.Y}` in res) || res[`${P.X}.${P.Y}`] < P.Z)) ? ({ ...res, [`${P.X}.${P.Y}`]: P.Z }) :
            (direction === 1 && blockBase[`${P.X}.${P.Z}`] && blockBase[`${P.X}.${P.Z}`].V > P.Y && (!(`${P.X}.${P.Z}` in res) || res[`${P.X}.${P.Z}`] < P.Y)) ? ({ ...res, [`${P.X}.${P.Z}`]: P.Y }) :
            (direction === 2 && blockBase[`${P.X}.${P.Y}`] && blockBase[`${P.X}.${P.Y}`].V < P.Z && (!(`${P.X}.${P.Y}` in res) || res[`${P.X}.${P.Y}`] > P.Z)) ? ({ ...res, [`${P.X}.${P.Y}`]: P.Z }) :
            (direction === 3 && blockBase[`${P.X}.${P.Z}`] && blockBase[`${P.X}.${P.Z}`].V < P.Y && (!(`${P.X}.${P.Z}` in res) || res[`${P.X}.${P.Z}`] > P.Y)) ? ({ ...res, [`${P.X}.${P.Z}`]: P.Y }) :
            (direction === 4 && blockBase[`${P.Y}.${P.Z}`] && blockBase[`${P.Y}.${P.Z}`].V > P.X && (!(`${P.Y}.${P.Z}` in res) || res[`${P.Y}.${P.Z}`] < P.X)) ? ({ ...res, [`${P.Y}.${P.Z}`]: P.X }) :
            (direction === 5 && blockBase[`${P.Y}.${P.Z}`] && blockBase[`${P.Y}.${P.Z}`].V < P.X && (!(`${P.Y}.${P.Z}` in res) || res[`${P.Y}.${P.Z}`] > P.X)) ? ({ ...res, [`${P.Y}.${P.Z}`]: P.X }) :
            res,
          {}
        );
        const diffBase =
          [0, 1, 4].includes(direction)
            ? capacity + 3 + Math.min(...Object.keys(blockBase).map((code) => blockBase[code].V))
            : capacity + 3 - Math.max(...Object.keys(blockBase).map((code) => blockBase[code].V));
        const diffs = Object.keys(blockBase)
          .filter(
            (code) =>
              code in blocksCover && (
                ([0, 1, 4].includes(direction) && blockBase[code].V >= blocksCover[code]) ||
                ([2, 3, 5].includes(direction) && blockBase[code].V <= blocksCover[code])
              )
          ).map(
            (code) => Math.abs(blockBase[code].V - blocksCover[code])
          );
        const diff = Math.min(diffBase, ...diffs);

        return { blockBase, blocksCover, diff };
      };

      const calculateBlockColor = ({ X, Y, Z }) => {
        const colorIndex = [X, Y, Z].reduce((N1, N2) => Math.max(N1, Math.abs(N2)), 0);

        return colorMap[colorIndex];
      };

      const output = () => {
        if (moveSwitch === true) {
          move();
          slide();
        }

        const surfaces = [];

        [
          ...(colorMode === 'agate' ? blocks.map((b) => ({ ...b, C: calculateBlockColor(b.P) })) : blocks),
          ...(block ? block.P.map((p) => ({ P: p, C: block.C })) : []),
          ...(fallingBlocks.map((B) => ({ ...B, F: true }))),
          ...(vanishingBlocks.map((B) => ({ ...B, K: true }))),
        ].forEach((B) => {
          const { P, C } = B;
          const [LX1, LX2] = [P.X + 1 / 2, P.X - 1 / 2];
          const [LY1, LY2] = [P.Y + 1 / 2, P.Y - 1 / 2];
          const [LZ1, LZ2] = [P.Z + 1 / 2, P.Z - 1 / 2];
          const pointPoses = [
            { X: LX1, Y: LY1, Z: LZ1 }, // 左上前
            { X: LX2, Y: LY1, Z: LZ1 }, // 右上前
            { X: LX1, Y: LY2, Z: LZ1 }, // 左下前
            { X: LX2, Y: LY2, Z: LZ1 }, // 右下前
            { X: LX1, Y: LY1, Z: LZ2 }, // 左上後
            { X: LX2, Y: LY1, Z: LZ2 }, // 右上後
            { X: LX1, Y: LY2, Z: LZ2 }, // 左下後
            { X: LX2, Y: LY2, Z: LZ2 }, // 右下後
          ].map((pos) => calculateBlockPosition(pos, true));
          const meshPoses = [
            { X: P.X, Y: P.Y, Z: P.Z }, // 中心
            { X: P.X, Y: P.Y, Z: LZ1 }, // 正面
            { X: P.X, Y: LY1, Z: P.Z }, // 上面
            { X: P.X, Y: LY2, Z: P.Z }, // 下面
            { X: LX1, Y: P.Y, Z: P.Z }, // 左面
            { X: LX2, Y: P.Y, Z: P.Z }, // 右面
            { X: P.X, Y: P.Y, Z: LZ2 }, // 背面
          ].map((pos) => calculateBlockPosition(pos, false));
          [
            { P: [pointPoses[0], pointPoses[1], pointPoses[3], pointPoses[2]], M: meshPoses[1] },
            { P: [pointPoses[0], pointPoses[1], pointPoses[5], pointPoses[4]], M: meshPoses[2] },
            { P: [pointPoses[0], pointPoses[2], pointPoses[6], pointPoses[4]], M: meshPoses[4] },
            { P: [pointPoses[1], pointPoses[3], pointPoses[7], pointPoses[5]], M: meshPoses[5] },
            { P: [pointPoses[2], pointPoses[3], pointPoses[7], pointPoses[6]], M: meshPoses[3] },
            { P: [pointPoses[4], pointPoses[5], pointPoses[7], pointPoses[6]], M: meshPoses[6] },
          ].forEach(({ P, M }) => {
            const Z = P.reduce((res, pos) => res + pos.Z, 0);
            const V = calculateRelativeVector(meshPoses[0], M);
            const F = B.F || false;
            const K = B.K || false;
            surfaces.push({ P, Z, C, V, F, K });
          });
        });

        if (block) {
          const { blockBase, blocksCover, diff } = calculateBlockIntervals();

          Object.keys(blockBase).forEach((code) => {
            const { P: { X, Y, Z }, V } = blockBase[code];
            const trajectoryPoses = Array(diff).fill(null).map(
              (_, i) => (
                  Array(4).fill(null).map((_, j) =>
                    direction === 0 ?
                      { X: X + ([0, 3].includes(j) ? 1 : -1) / 2, Y: Y + ([0, 1].includes(j) ? 1 : -1) / 2, Z: Z - i - 1 / 2 } :
                    direction === 1 ?
                      { X: X + ([0, 3].includes(j) ? 1 : -1) / 2, Z: Z + ([0, 1].includes(j) ? 1 : -1) / 2, Y: Y - i - 1 / 2 } :
                    direction === 2 ?
                      { X: X + ([0, 3].includes(j) ? 1 : -1) / 2, Y: Y + ([0, 1].includes(j) ? 1 : -1) / 2, Z: Z + i + 1 / 2 } :
                    direction === 3 ?
                      { X: X + ([0, 3].includes(j) ? 1 : -1) / 2, Z: Z + ([0, 1].includes(j) ? 1 : -1) / 2, Y: Y + i + 1 / 2 } :
                    direction === 4 ?
                      { Y: Y + ([0, 3].includes(j) ? 1 : -1) / 2, Z: Z + ([0, 1].includes(j) ? 1 : -1) / 2, X: X - i - 1 / 2 } :
                      { Y: Y + ([0, 3].includes(j) ? 1 : -1) / 2, Z: Z + ([0, 1].includes(j) ? 1 : -1) / 2, X: X + i + 1 / 2 }
                  )
              )
            ).map(
              (ps) => ps.map((p) => calculateBlockPosition(p, true))
            );

            trajectoryPoses.forEach((p1, i) => {
              if (i > 0) {
                const p0 = trajectoryPoses[i - 1];
                Array(4).fill(null).forEach((_, j) => {
                  const nextP1 = ([0, 1, 2, 3].includes(direction) ? X : Y) + (j === 3 ? 1 : j === 1 ? -1 : 0);
                  const nextP2 = ([1, 3, 4, 5].includes(direction) ? Z : Y) + (j === 0 ? 1 : j === 2 ? -1 : 0);
                  const nextPos = blockBase[`${nextP1}.${nextP2}`];
                  if (nextPos) {
                    if ([0, 1, 4].includes(direction) && nextPos.V - diff <= V - i - 1) return;
                    if ([2, 3, 5].includes(direction) && nextPos.V + diff >= V + i + 1) return;
                  }
                  const P = [p0[j], p0[(j + 1) % 4], p1[(j + 1) % 4], p1[j]];
                  const L = [];
                  const cornerPT1 = ([0, 1, 2, 3].includes(direction) ? X : Y) + (j === 2 ? 1 : j === 0 ? -1 : 0);
                  const cornerPT2 = ([1, 3, 4, 5].includes(direction) ? Z : Y) + (j === 3 ? 1 : j === 1 ? -1 : 0);
                  const cornerPN1 = ([0, 1, 2, 3].includes(direction) ? X : Y) + ([0, 1].includes(j) ? -1 : 1);
                  const cornerPN2 = ([1, 3, 4, 5].includes(direction) ? Z : Y) + ([1, 2].includes(j) ? -1 : 1);
                  const cornerPosT = blockBase[`${cornerPT1}.${cornerPT2}`];
                  const cornerPosN = blockBase[`${cornerPN1}.${cornerPN2}`];
                  if (
                    (
                      !cornerPosT ||
                      ([0, 1, 4].includes(direction) && cornerPosT.V - diff > V - i - 1) ||
                      ([2, 3, 5].includes(direction) && cornerPosT.V + diff < V + i + 1)
                    ) || (
                      cornerPosN && (
                        ([0, 1, 4].includes(direction) && cornerPosN.V > V - i && cornerPosN.V - diff <= V - i - 1) ||
                        ([2, 3, 5].includes(direction) && cornerPosN.V < V + i && cornerPosN.V + diff >= V + i + 1)
                      )
                    )
                  ) {
                    L.push([p0[(j + 1) % 4], p1[(j + 1) % 4]]);
                  }
                  surfaces.push({ P, L, Z: P.reduce((z, p) => z + p.Z, 0) });
                });
              }
              if (i === diff - 1) {
                surfaces.push({ P: p1, Z: p1.reduce((z, p) => z + p.Z, 0) });
              }
            });
          });
        }

        surfaces.sort((A, B) => A.Z - B.Z);

        const framePoses = [
          { X: capacity, Y: capacity, Z: capacity },
          { X: capacity * -1, Y: capacity, Z: capacity },
          { X: capacity, Y: capacity * -1, Z: capacity },
          { X: capacity * -1, Y: capacity * -1, Z: capacity },
          { X: capacity, Y: capacity, Z: capacity * -1 },
          { X: capacity * -1, Y: capacity, Z: capacity * -1 },
          { X: capacity, Y: capacity * -1, Z: capacity * -1 },
          { X: capacity * -1, Y: capacity * -1, Z: capacity * -1 },
        ].map((pos) => calculateBlockPosition(pos, true));
        const frameLines = [
          [framePoses[0], framePoses[1]],
          [framePoses[0], framePoses[2]],
          [framePoses[0], framePoses[4]],
          [framePoses[3], framePoses[1]],
          [framePoses[3], framePoses[2]],
          [framePoses[3], framePoses[7]],
          [framePoses[5], framePoses[1]],
          [framePoses[5], framePoses[4]],
          [framePoses[5], framePoses[7]],
          [framePoses[6], framePoses[2]],
          [framePoses[6], framePoses[4]],
          [framePoses[6], framePoses[7]],
        ].sort((A, B) => A[0].Z + A[1].Z - B[0].Z - B[1].Z);

        displayContext.clearRect(0, 0, displaySize, displaySize);

        displayContext.strokeStyle = '#aaddff88';
        Array(6).fill(null).forEach((_, i) => {
          displayContext.beginPath();
          displayContext.moveTo(displayRadius + frameLines[i][0].X, displayRadius + frameLines[i][0].Y);
          displayContext.lineTo(displayRadius + frameLines[i][1].X, displayRadius + frameLines[i][1].Y);
          displayContext.stroke();
        });

        const alpha =
          phase === 'vanish' ? (5 - Math.min(Math.max(phaseTime, 3), 5)) / 2 :
          phase === 'strip' ?  (24 - Math.min(phaseTime, 24)) / 24 : 1;
        const alpha10 = Math.round(colorAlpha1 * alpha);
        const alpha20 = Math.round(colorAlpha2 * alpha);
        const alpha1 = (alpha10 < 16 ? '0' : '') + alpha10.toString(16);
        const alpha2 = (alpha20 < 16 ? '0' : '') + alpha20.toString(16);

        surfaces.forEach((mesh, n) => {
          if (!mesh.C) {
            if (mesh.L) {
              displayContext.fillStyle = '#ff88aa22';
              displayContext.strokeStyle = '#ff88aa44';
              // displayContext.fillStyle = '#aaaaff22';
              // displayContext.strokeStyle = '#aaaaff44';
              displayContext.beginPath();
              mesh.P.forEach(({ X, Y, Z }, j) => {
                j === 0
                  ? displayContext.moveTo(displayRadius + X, displayRadius + Y)
                  : displayContext.lineTo(displayRadius + X, displayRadius + Y);
              });
              displayContext.closePath();
              displayContext.fill();

              mesh.L.forEach((L) => {
                displayContext.beginPath();
                displayContext.moveTo(displayRadius + L[0].X, displayRadius + L[0].Y);
                displayContext.lineTo(displayRadius + L[1].X, displayRadius + L[1].Y);
                displayContext.stroke();
              });
            } else {
              displayContext.fillStyle = '#ff88aa66';
              displayContext.strokeStyle = '#ff88aa88';
              // displayContext.fillStyle = '#aaaaff66';
              // displayContext.strokeStyle = '#aaaaff88';
              displayContext.beginPath();
              mesh.P.forEach(({ X, Y, Z }, j) => {
                j === 0
                  ? displayContext.moveTo(displayRadius + X, displayRadius + Y)
                  : displayContext.lineTo(displayRadius + X, displayRadius + Y);
              });
              displayContext.closePath();
              displayContext.fill();
            }

            return;
          }

          let V = mesh.V / Math.PI;
          let [A1, A2] = [
            `${colorAlpha1 < 16 ? '0' : ''}${colorAlpha1.toString(16)}`,
            `${colorAlpha2 < 16 ? '0' : ''}${colorAlpha2.toString(16)}`,
          ];
          if (phase === 'vanish' && mesh.K) {
            const T = Math.PI / 2 * (Math.min(phaseTime, 10) / 10);
            V *= Math.cos(T);
            [A1, A2] = [alpha1, alpha2];
          } else if (phase === 'strip' && mesh.F) {
            [A1, A2] = [alpha1, alpha2];
          }
          displayContext.fillStyle   = calculateColor(mesh.C, V) + A1;
          displayContext.strokeStyle = calculateColor(mesh.C, V) + A2;
          displayContext.beginPath();
          mesh.P.forEach(({ X, Y }, j) => {
            j === 0
              ? displayContext.moveTo(displayRadius + X, displayRadius + Y)
              : displayContext.lineTo(displayRadius + X, displayRadius + Y);
          });
          displayContext.closePath();
          displayContext.fill();
          displayContext.stroke();
        });

        displayContext.strokeStyle = '#aaddffaa';
        Array(6).fill(null).forEach((_, i) => {
          displayContext.beginPath();
          displayContext.moveTo(displayRadius + frameLines[6 + i][0].X, displayRadius + frameLines[6 + i][0].Y);
          displayContext.lineTo(displayRadius + frameLines[6 + i][1].X, displayRadius + frameLines[6 + i][1].Y);
          displayContext.stroke();
        });

        if (block) {
          const { S: { X, Y, Z } } = block;
          const { X: SX, Y: SY, Z: SZ } = calculateBlockPosition({ X, Y, Z }, true);
          const PS = (
            direction === 0 ? [
              [{ X, Y: Y + 5, Z }, { X: X + 1, Y: Y + 4, Z }, { X: X - 1, Y: Y + 4, Z }],
              [{ X: X - 5, Y, Z }, { X: X - 4, Y: Y + 1, Z }, { X: X - 4, Y: Y - 1, Z }],
              [{ X, Y: Y - 5, Z }, { X: X + 1, Y: Y - 4, Z }, { X: X - 1, Y: Y - 4, Z }],
              [{ X: X + 5, Y, Z }, { X: X + 4, Y: Y + 1, Z }, { X: X + 4, Y: Y - 1, Z }],
            ] :
            direction === 1 ? [
              [{ X, Y, Z: Z - 5 }, { X: X + 1, Y, Z: Z - 4 }, { X: X - 1, Y, Z: Z - 4 }],
              [{ X: X - 5, Y, Z }, { X: X - 4, Y, Z: Z + 1 }, { X: X - 4, Y, Z: Z - 1 }],
              [{ X, Y, Z: Z + 5 }, { X: X + 1, Y, Z: Z + 4 }, { X: X - 1, Y, Z: Z + 4 }],
              [{ X: X + 5, Y, Z }, { X: X + 4, Y, Z: Z + 1 }, { X: X + 4, Y, Z: Z - 1 }],
            ] :
            direction === 2 ? [
              [{ X, Y: Y - 5, Z }, { X: X - 1, Y: Y - 4, Z }, { X: X + 1, Y: Y - 4, Z }],
              [{ X: X + 5, Y, Z }, { X: X + 4, Y: Y - 1, Z }, { X: X + 4, Y: Y + 1, Z }],
              [{ X, Y: Y + 5, Z }, { X: X - 1, Y: Y + 4, Z }, { X: X + 1, Y: Y + 4, Z }],
              [{ X: X - 5, Y, Z }, { X: X - 4, Y: Y - 1, Z }, { X: X - 4, Y: Y + 1, Z }],
            ] :
            direction === 3 ? [
              [{ X, Y, Z: Z + 5 }, { X: X - 1, Y, Z: Z + 4 }, { X: X + 1, Y, Z: Z + 4 }],
              [{ X: X + 5, Y, Z }, { X: X + 4, Y, Z: Z - 1 }, { X: X + 4, Y, Z: Z + 1 }],
              [{ X, Y, Z: Z - 5 }, { X: X - 1, Y, Z: Z - 4 }, { X: X + 1, Y, Z: Z - 4 }],
              [{ X: X - 5, Y, Z }, { X: X - 4, Y, Z: Z - 1 }, { X: X - 4, Y, Z: Z + 1 }],
            ] :
            direction === 4 ? [
              [{ X, Y: Y + 5, Z }, { X, Y: Y + 4, Z: Z + 1 }, { X, Y: Y + 4, Z: Z - 1 }],
              [{ X, Y, Z: Z + 5 }, { X, Y: Y + 1, Z: Z + 4 }, { X, Y: Y - 1, Z: Z + 4 }],
              [{ X, Y: Y - 5, Z }, { X, Y: Y - 4, Z: Z + 1 }, { X, Y: Y - 4, Z: Z - 1 }],
              [{ X, Y, Z: Z - 5 }, { X, Y: Y + 1, Z: Z - 4 }, { X, Y: Y - 1, Z: Z - 4 }],
            ] :
            [
              [{ X, Y: Y + 5, Z }, { X, Y: Y + 4, Z: Z + 1 }, { X, Y: Y + 4, Z: Z - 1 }],
              [{ X, Y, Z: Z - 5 }, { X, Y: Y + 1, Z: Z - 4 }, { X, Y: Y - 1, Z: Z - 4 }],
              [{ X, Y: Y - 5, Z }, { X, Y: Y - 4, Z: Z + 1 }, { X, Y: Y - 4, Z: Z - 1 }],
              [{ X, Y, Z: Z + 5 }, { X, Y: Y + 1, Z: Z + 4 }, { X, Y: Y - 1, Z: Z + 4 }],
            ]
          ).map(
            (P) => (P.map((p) => calculateBlockPosition(p, true)))
          );
          const CS = ['#00aa00', '#0000ff', '#ffff00', '#ff0000'];
          const [PUI] = PS.reduce(([I, T0], P, i) => {
            const X1 = P[0].X - SX;
            const Y1 = P[0].Y - SY;
            const L1 = Math.pow(X1 * X1 + Y1 * Y1, 1 / 2);
            const T1 = L1 > 0 ? Math.abs(Math.acos(Y1 / L1)) : 0;

            return T0 && T0 < T1 ? [I, T0] : [i, T1];
          }, [0, null]);
          const [PLI] = [(PUI + 1) % 4, (PUI + 3) % 4].reduce(([I, T0], i) => {
            const P1 = PS[i];
            const X1 = P1[0].X - SX;
            const Y1 = P1[0].Y - SY;
            const L1 = Math.pow(X1 * X1 + Y1 * Y1, 1 / 2);
            const T1 = L1 > 0 ? Math.abs(Math.acos(X1 / L1)) : 0;

            return T0 && T0 < T1 ? [I, T0] : [i, T1];
          }, [(PUI + 1) % 4, null]);
          directionMap.U = PUI;
          directionMap.L = PLI;
          directionMap.D = (PUI + 2) % 4;
          directionMap.R = (PLI + 2) % 4;
          ['U', 'R', 'D', 'L'].forEach((D, i) => {
            PS[directionMap[D]] = { P: PS[directionMap[D]], C: CS[i] };
          });

          PS.forEach(({ P, C }) => {
            displayContext.fillStyle = C + '88';
            displayContext.strokeStyle = C + 'aa';
            displayContext.beginPath();
            P.forEach(({ X, Y }, j) => {
              j === 0
                ? displayContext.moveTo(displayRadius + X, displayRadius + Y)
                : displayContext.lineTo(displayRadius + X, displayRadius + Y);
            });
            displayContext.closePath();
            displayContext.fill();
            displayContext.stroke();
          });
        }

        scoreDisplay.innerText = score;
      };

      const move = () => {
        positionAxisX = axisX;
        positionAxisY = axisY;
        positionAxisL = axisL;

        if (moveType === 'vector') {
          const diffX = latestMoveX - latestBaseX;
          const diffY = latestMoveY - latestBaseY;
          const diffL = Math.pow(diffX * diffX + diffY * diffY, 1 / 2);
          const diffR = Math.max(diffL, displayRadius / 100);

          if (diffL > 0) {
            momentAxisY = Math.acos(diffY / diffL) * (diffX >= 0 ? 1 : -1) + Math.PI / 2;
          }
          momentAxisX = Math.PI / 2;
          momentAxisL = 0;
          diffAxisL = diffR > 0 ? Math.asin(diffR / displayRadius) : 0;
        } else {
          const X1 = latestBaseX - displayRadius;
          const Y1 = latestBaseY - displayRadius;
          const X2 = latestMoveX - displayRadius;
          const Y2 = latestMoveY - displayRadius;
          const L1 = Math.pow(X1 * X1 + Y1 * Y1, 1 / 2);
          const L2 = Math.pow(X2 * X2 + Y2 * Y2, 1 / 2);
          const T1 = L1 > 0 ? Math.acos(Y1 / L1) * (X1 >= 0 ? 1 : -1) : 0;
          const T2 = L2 > 0 ? Math.acos(Y2 / L2) * (X2 >= 0 ? 1 : -1) : 0;

          momentAxisX = 0;
          momentAxisY = 0;
          momentAxisL = 0;
          diffAxisL = T2 - T1;
        }

        latestBaseX = latestMoveX;
        latestBaseY = latestMoveY;
      };

      const slide = () => {
        momentAxisL += diffAxisL;

        const RZ0 = Math.sin(positionAxisX); // Z面上の半径
        const LZ0 = Math.cos(positionAxisX); // Z軸上の中心点との距離
        const TZ1 = positionAxisY - momentAxisY; // 回転軸に対するZ面上の相対角度
        const LX1 = Math.sin(TZ1) * RZ0; // 回転軸に対するX軸上の相対距離
        const LY1 = Math.cos(TZ1) * RZ0; // 回転軸に対するY軸上の相対距離
        const RX1 = Math.pow(LY1 * LY1 + LZ0 * LZ0, 1 / 2);
        const TX1 = RX1 > 0 ? Math.acos(LZ0 / RX1) * (LY1 >= 0 ? 1 : -1) : 0;
        const TX2 = TX1 - momentAxisX; // 回転軸に対するX面上の相対角度
        const LY2 = Math.sin(TX2) * RX1;
        const LZ2 = Math.cos(TX2) * RX1;
        const RZ2 = Math.pow(LX1 * LX1 + LY2 * LY2, 1 / 2);
        const TZ2 = RZ2 > 0 ? Math.acos(LY2 / RZ2) * (LX1 >= 0 ? 1 : -1) : 0;
        const TZ3 = TZ2 + momentAxisL; // 回転角度に対するZ面上の相対角度
        const LX3 = Math.sin(TZ3) * RZ2;
        const LY3 = Math.cos(TZ3) * RZ2;
        const RX3 = Math.pow(LY3 * LY3 + LZ2 * LZ2, 1 / 2);
        const TX3 = RX3 > 0 ? Math.acos(LZ2 / RX3) * (LY3 >= 0 ? 1 : -1) : 0;
        const TX4 = TX3 + momentAxisX;
        const LY4 = Math.sin(TX4) * RX3;
        const LZ4 = Math.cos(TX4) * RX3;
        const RZ4 = Math.pow(LX3 * LX3 + LY4 * LY4, 1 / 2);
        const TZ4 = RZ4 > 0 ? Math.acos(LY4 / RZ4) * (LX3 >= 0 ? 1 : -1) : 0;
        const TZ5 = TZ4 + momentAxisY;
        const RX5 = Math.pow(RZ4 * RZ4 + LZ4 * LZ4, 1 / 2);
        const TX5 = RX5 > 0 ? Math.acos(LZ4 / RX5) : 0;

        const L_LX0 = Math.sin(positionAxisL);
        const L_LY0 = Math.cos(positionAxisL) * Math.cos(positionAxisX);
        const L_LZ0 = Math.cos(positionAxisL) * Math.sin(positionAxisX) * -1;
        const L_RZ0 = Math.pow(L_LX0 * L_LX0 + L_LY0 * L_LY0, 1 / 2);
        const L_TZ0 = L_RZ0 > 0 ? Math.acos(L_LY0 / L_RZ0) * (L_LX0 >= 0 ? 1 : -1) : 0;
        const L_TZ1 = L_TZ0 + positionAxisY - momentAxisY;
        const L_LX1 = Math.sin(L_TZ1) * L_RZ0;
        const L_LY1 = Math.cos(L_TZ1) * L_RZ0;
        const L_RX1 = Math.pow(L_LY1 * L_LY1 + L_LZ0 * L_LZ0, 1 / 2);
        const L_TX1 = L_RX1 > 0 ? Math.acos(L_LZ0 / L_RX1) * (L_LY1 >= 0 ? 1 : -1) : 0;
        const L_TX2 = L_TX1 - momentAxisX;
        const L_LY2 = Math.sin(L_TX2) * L_RX1;
        const L_LZ2 = Math.cos(L_TX2) * L_RX1;
        const L_RZ2 = Math.pow(L_LX1 * L_LX1 + L_LY2 * L_LY2, 1 / 2);
        const L_TZ2 = L_RZ2 > 0 ? Math.acos(L_LY2 / L_RZ2) * (L_LX1 >= 0 ? 1 : -1) : 0;
        const L_TZ3 = L_TZ2 + momentAxisL;
        const L_LX3 = Math.sin(L_TZ3) * L_RZ2;
        const L_LY3 = Math.cos(L_TZ3) * L_RZ2;
        const L_RX3 = Math.pow(L_LY3 * L_LY3 + L_LZ2 * L_LZ2, 1 / 2);
        const L_TX3 = L_RX3 > 0 ? Math.acos(L_LZ2 / L_RX3) * (L_LY3 >= 0 ? 1 : -1) : 0;
        const L_TX4 = L_TX3 + momentAxisX;
        const L_LY4 = Math.sin(L_TX4) * L_RX3;
        const L_LZ4 = Math.cos(L_TX4) * L_RX3;
        const L_RZ4 = Math.pow(L_LX3 * L_LX3 + L_LY4 * L_LY4, 1 / 2);
        const L_TZ4 = L_RZ4 > 0 ? Math.acos(L_LY4 / L_RZ4) * (L_LX3 >= 0 ? 1 : -1) : 0;
        const L_TZ5 = L_TZ4 - TZ4;
        const L_LX5 = Math.sin(L_TZ5) * L_RZ4;
        const L_LY5 = Math.cos(L_TZ5) * L_RZ4;
        const L_RX5 = Math.pow(L_LY5 * L_LY5 + L_LZ4 * L_LZ4, 1 / 2);
        const L_TX5 = L_RX5 > 0 ? Math.acos(L_LZ4 / L_RX5) * (L_LY5 >= 0 ? 1 : -1) : 0;
        const L_TX6 = L_TX5 - TX5;
        const L_LY6 = Math.sin(L_TX6) * L_RX5;
        const L_RZ6 = Math.pow(L_LX5 * L_LX5 + L_LY6 * L_LY6, 1 / 2);
        const L_TZ6 = L_RZ6 > 0 ? Math.acos(L_LY6 / L_RZ6) * (L_LX5 >= 0 ? 1 : -1) : 0;

        axisX = TX5;
        axisY = TZ5;
        axisL = L_TZ6;
      };

      const summonBlock = () => {
        direction = Math.floor(Math.random() * 6);
        const B = blockFormations[Math.floor(Math.random() * blockFormations.length)];
        const S = {
          X: (direction === 4 ? capacity : direction === 5 ? (capacity * -1) : 0),
          Y: (direction === 1 ? capacity : direction === 3 ? (capacity * -1) : 0),
          Z: (direction === 0 ? capacity : direction === 2 ? (capacity * -1) : 0),
        };
        const P = B.P.map(([X, Y]) => ({ X: S.X + X, Y: S.Y + Y, Z: S.Z }));

        if (P.find(({ X, Y, Z }) => blocks.find(({ P: { X: BX, Y: BY, Z: BZ } }) => BX === X && BY === Y && BZ === Z))) return -1;

        block = { P, C: B.C, S };

        rotateBlock(
          Math.floor(Math.random() * 4),
          Math.floor(Math.random() * 4),
          Math.floor(Math.random() * 4),
        );

        return 0;
      };

      const rotateBlock = (RZ, RX, RY) => {
        block.P.forEach(({ X, Y, Z }, i) => {
          [X, Y, Z] = [X - block.S.X, Y - block.S.Y, Z - block.S.Z];
          [X, Y] = RZ === 1 ? [Y, X * -1] : RZ === 2 ? [X * -1, Y * -1] : RZ === 3 ? [Y * -1, X] : [X, Y];
          [Y, Z] = RX === 1 ? [Z, Y * -1] : RX === 2 ? [Y * -1, Z * -1] : RX === 3 ? [Z * -1, Y] : [Y, Z];
          [X, Z] = RY === 1 ? [Z, X * -1] : RY === 2 ? [X * -1, Z * -1] : RY === 3 ? [Z * -1, X] : [X, Z];
          [block.P[i].X, block.P[i].Y, block.P[i].Z] = [X + block.S.X, Y + block.S.Y, Z + block.S.Z];
        });
      };

      const slideBlock = (direction) => {
        const [P, [S]] = [block.P, [block.S]].map(
          (ps) => ps.map((p) => ({
            ...p,
            X: p.X + (direction === 4 ? 1 : direction === 5 ? -1 : 0),
            Y: p.Y + (direction === 1 ? 1 : direction === 3 ? -1 : 0),
            Z: p.Z + (direction === 0 ? 1 : direction === 2 ? -1 : 0),
          }))
        );

        if (P.find(
            (p) => blocks.find(
              (b) => b.P.X === p.X && b.P.Y === p.Y && b.P.Z === p.Z
            )
        )) {
          return -1;
        }

        if (P.find(
          (p) => Math.abs(p.X) > capacity + 2 || Math.abs(p.Y) > capacity + 2 || Math.abs(p.Z) > capacity + 2
        )) {
          return -2;
        }

        block.P = P;
        block.S = S;

        return 0;
      };

      const pushDownBlock = () => {
        const { blockBase, blocksCover, diff } = calculateBlockIntervals();
        const [K1, K2, K3, S3, V3] = vectorMap[direction];

        block.P.forEach((P) => {
          P[K3] += (diff - 1) * V3;
        });
      };

      const inspectBlocks = () => {
        block.P.forEach((p) => {
          blocks.push({ P: { ...p }, C: block.C });
        });

        const afterBlocks = [{ P: { X:  0, Y:  0, Z:  0 }, C: [200, 255, 248] }];

        try {
          Array(capacity).fill(null).forEach((_1, i) => {
            const layerBlocks = [];

            Array(6).fill(null).forEach((_2, j) => {
              const [PK1, PS1, PL1, PK2, PS2, PL2, PK3, P3] = [
                ['X', (i + 1) * -1, (i + 1) * 2 + 1, 'Y', (i + 1) * -1, (i + 1) * 2 + 1, 'Z', i + 1],
                ['X', (i + 1) * -1, (i + 1) * 2 + 1, 'Z', i * -1, (i + 1) * 2 - 1, 'Y', i + 1],
                ['X', (i + 1) * -1, (i + 1) * 2 + 1, 'Y', (i + 1) * -1, (i + 1) * 2 + 1, 'Z', i * -1 - 1],
                ['X', (i + 1) * -1, (i + 1) * 2 + 1, 'Z', i * -1, (i + 1) * 2 - 1, 'Y', i  * -1 - 1],
                ['Y', i * -1, (i + 1) * 2 - 1, 'Z', i * -1, (i + 1) * 2 - 1, 'X', i + 1],
                ['Y', i * -1, (i + 1) * 2 - 1, 'Z', i * -1, (i + 1) * 2 - 1, 'X', i * -1 - 1],
              ][j];
              Array(PL1).fill(null).forEach((_31, PI1) => {
                const P1 = PS1 + PI1;
                Array(PL2).fill(null).forEach((_32, PI2) => {
                  const P2 = PS2 + PI2;
                  const P = blocks.find(({ P: p }) => p[PK1] === P1 && p[PK2] === P2 && p[PK3] === P3);
                  if (P) layerBlocks.push(P);
                });
              });
            });

            if (layerBlocks.length === 0) throw null;
            if (layerBlocks.length === Math.pow((i + 1) * 2 + 1, 3) - Math.pow(i * 2 + 1, 3)) {
              vanishingBlocks = vanishingBlocks.concat(layerBlocks);
              score += Math.pow(200, i + 1);
            } else {
              layerBlocks.forEach((b) => {
                afterBlocks.push(b);
              });
            }
          });
        } catch (_e) {
        }

        if (afterBlocks.length === blocks.length) return;

        let blockChain = { '0.0.0': { P: [afterBlocks[0]], BP: [] } };
        const blockRelations = { '0.0.0': '0.0.0' };
        const [K1, K2, K3, S3, V3] = vectorMap[direction];

        afterBlocks.forEach((BA) => {
          const { P: { [K1]: P1, [K2]: P2, [K3]: P3 } } = BA;
          const KA = `${P1}.${P2}.${P3}`;
          let isBase = false;

          [[P1 + 1, P2, P3], [P1, P2 + 1, P3], [P1, P2, P3 + V3]].forEach(([NP1, NP2, NP3], l) => {
            const IB = afterBlocks.findIndex(({ P }) => P[K1] === NP1 && P[K2] === NP2 && P[K3] === NP3);
            if (IB >= 0) {
              const BB = afterBlocks[IB];
              const KB = `${NP1}.${NP2}.${NP3}`;
              if (blockRelations[KA] && blockRelations[KB]) {
                const { [KA]: KC, [KB]: KD } = blockRelations;
                if (KC !== KD) {
                  const [KE, KF] = KC === '0.0.0' ? [KC, KD] : [KD, KC];
                  const { [KF]: { P, BP }, ...afterBlockChain } = blockChain;
                  P.forEach((b) => {
                    afterBlockChain[KE].P.push(b);
                    blockRelations[`${b.P[K1]}.${b.P[K2]}.${b.P[K3]}`] = KE;
                  });
                  afterBlockChain[KE].BP = afterBlockChain[KE].BP.concat(BP);
                  blockChain = afterBlockChain;
                }
              } else if (blockRelations[KA]) {
                blockChain[blockRelations[KA]].P.push(BB);
                blockRelations[KB] = blockRelations[KA];
              } else if (blockRelations[KB]) {
                blockChain[blockRelations[KB]].P.push(BA);
                blockRelations[KA] = blockRelations[KB];
              } else {
                blockChain[KA] = { P: [BA, BB], BP: [] };
                blockRelations[KA] = KA;
                blockRelations[KB] = KA;
              }
            } else if (l === 2) {
              isBase = true;
            }
          });
          if (!blockRelations[KA]) {
            blockRelations[KA] = KA;
            blockChain[KA] = { P: [BA], BP: [] };
          }
          if (isBase) {
            blockChain[blockRelations[KA]].BP.push(BA);
          }
        });

        const { '0.0.0': coreChain, ...fallingChain } = blockChain;
        phaseTime = 0;
        block = null;
        blocks = coreChain.P;
        fallingParams = [];
        fallingBlocks = [];

        try {
          Object.keys(fallingChain).forEach((_) => {
            const coreCovers = {};

            coreChain.P.forEach((P) => {
              const { P: { [K1]: P1, [K2]: P2, [K3]: P3 } } = P;
              const K = `${P1}.${P2}`;
              if (!(K in coreCovers)) coreCovers[K] = [];
              if (!blocks.find(({ P: { [K1]: NP1, [K2]: NP2, [K3]: NP3 } }) => NP1 === P1 && NP2 === P2 && NP3 === P3 - V3)) {
                coreCovers[K].push(P3);
              }
              fallingBlocks.push(P);
            });

            const fallingParam = Object.keys(fallingChain).map((code) => {
              let [D, I] = [capacity * 2, false];

              fallingChain[code].BP.forEach(({ P: { [K1]: P1, [K2]: P2, [K3]: P3 } }) => {
                if (coreCovers[`${P1}.${P2}`]) {
                  coreCovers[`${P1}.${P2}`].forEach((CP3) => {
                    const d = (CP3 - P3) * V3;
                    if (d > 0 && d < D) [D, I] = [d, true];
                  });
                }
              });

              return { ...fallingChain[code], C: code, D, I };
            }).sort(
              (A, B) => A.D - B.D
            ).reduce((res, param, i) => {
              if (i === 0) {
                delete fallingChain[param.C];

                return param;
              }

              if (param.I && res.I && param.D === res.D) {
                delete fallingChain[param.C];
                res.P = res.P.concat(param.P);
                res.BP = res.P.concat(param.BP);
              }

              return res;
            }, null);

            fallingParams.push(fallingParam);

            if (!Object.keys(fallingChain).length) throw null;
          });
        } catch (_e) {
        }
      };

      const makeFallingBlocks = () => {
        const [K1, K2, K3, S3, V3] = vectorMap[direction];

        const PR3 = Math.pow(phaseTime, 2) * 0.02;
        let lastIndex = null;

        fallingBlocks = [];
        fallingParams.forEach((fallingParam, i) => {
          const isLast = PR3 >= fallingParam.D - 1;
          fallingParam.P.forEach((B) => {
            if (isLast) {
              if (fallingParam.I) {
                blocks.push({ ...B, P: { ...B.P, [K3]: B.P[K3] + V3 * (fallingParam.D - 1) } });
              }
            } else {
              fallingBlocks.push({ ...B, P: { ...B.P, [K3]: B.P[K3] + V3 * PR3 } });
            }
          });
          if (isLast) {
            lastIndex = i;
          }
        });

        if (lastIndex !== null) {
          fallingParams = fallingParams.splice(lastIndex + 1);
        }
        if (!fallingParams.length) {
          fallingParams = null;
          fallingBlocks = [];
        }
      };

      const animate = () => {
        if (!animationSwitch) return;

        switch (phase) {
          case 'set':
            const setResult = summonBlock();
            if (setResult === -1) {
              stopAnimation();
              showFailedDialog();
              phase = 'failed';
            } else {
              phase = 'fall';
            }
            break;
          case 'fall':
            const slidedResult = slideBlock([2, 3, 0, 1, 5, 4][direction]);
            if (slidedResult === -1) {
              inspectBlocks();
              if (vanishingBlocks.length) {
                makeFallingBlocks();
                phase = 'vanish';
              } else {
                phase = 'set';
              }
              score += 40;
            } else if (slidedResult === -2) {
              phase = 'set';
              score -= 20;
            }
            break;
          case 'vanish':
            if (phaseTime > 5) {
              phaseTime = 0;
              vanishingBlocks = [];
              phase = 'strip';
            } else {
              phaseTime ++;
            }
            break;
          case 'strip':
            if (!fallingParams || phaseTime > 100) {
              phase = 'set';
            } else {
              makeFallingBlocks();
              phaseTime ++;
            }
            break;
        }

        output();

        time = (new Date()).getTime();
        nextTime = time + phaseTimes[phase];
        animation = setTimeout(animate, nextTime - time);
      };

      const startAnimation = () => {
        if (animation) clearTimeout(animation);
        animationSwitch = true;
        if (nextTime > time) {
          animation = setTimeout(animate, nextTime - time);
        } else {
          animate();
        }
      };

      const stopAnimation = () => {
        animationSwitch = false;
        if (animation) clearTimeout(animation);
        time = (new Date()).getTime();
      };

      const getClientPosition = (event) => ({
        X: event.clientX !== undefined ? event.clientX : event.changedTouches[0].clientX,
        Y: event.clientY !== undefined ? event.clientY : event.changedTouches[0].clientY,
      });

      const showFailedDialog = () => {
        failedDialog.style.display = 'flex';
      };

      const displayOnpointerdown = (event) => {
        if (moveSwitch === true || meterSwitch === true) return;

        const { X, Y } = getClientPosition(event);

        moveSwitch = true;
        latestMoveX = X;
        latestMoveY = Y;
        latestBaseX = X;
        latestBaseY = Y;

        const displayRect = display.getBoundingClientRect();
        const relativeDiffX = X - displayRect.left - displayRadius;
        const relativeDiffY = Y - displayRect.top - displayRadius;
        const relativeDiffRadius = Math.pow(relativeDiffX * relativeDiffX + relativeDiffY * relativeDiffY, 1 / 2);
        moveType = relativeDiffRadius <= vectorSlideRadius ? 'vector' : 'rotate';
      };

      const documentMousemove = (event) => {
        const { X, Y } = getClientPosition(event);

        if (moveSwitch) {
          latestMoveX = X;
          latestMoveY = Y;
          output();
          latestBaseX = X;
          latestBaseY = Y;
        }
        if (meterSwitch) {
          setMeterLength(meterSwitch, X);
        }
      };

      document.onpointerup = (event) => {
        if (moveSwitch === true) {
          moveSwitch = false;

          const { X, Y } = getClientPosition(event);
          latestMoveX = X;
          latestMoveY = Y;
        }

        setMeterSwitch(false);
      };

      document.onkeydown = (event) => {
        switch (event.code) {
          case 'Enter':
            if (animationSwitch === false) {
              startAnimation();
            } else {
              stopAnimation();
            }

            break;
          case 'ShiftLeft':
          case 'ShiftRight':
            rotationSwitch = true;
            break;

          case 'ArrowUp':
          case 'ArrowRight':
          case 'ArrowDown':
          case 'ArrowLeft':
            const key = keyMap[event.code];
            const index = directionMap[key];
            if (rotationSwitch) {
              let [ZR, ZX, ZY] = [0, 0, 0];
              const { U, L } = directionMap;

              if (direction === 0) {
                ZX = [0, 2].includes(index) ? (((key === 'U' && L === 1) || (key === 'R' && U === 1) || (key === 'D' && L === 3) || (key === 'L' && U === 3)) ? 1 : 3) : 0;
                ZY = [1, 3].includes(index) ? (((key === 'U' && L === 0) || (key === 'R' && U === 0) || (key === 'D' && L === 2) || (key === 'L' && U === 2)) ? 1 : 3) : 0;
              }
              if (direction === 2) {
                ZX = [0, 2].includes(index) ? (((key === 'U' && L === 3) || (key === 'R' && U === 3) || (key === 'D' && L === 1) || (key === 'L' && U === 1)) ? 1 : 3) : 0;
                ZY = [1, 3].includes(index) ? (((key === 'U' && L === 2) || (key === 'R' && U === 2) || (key === 'D' && L === 0) || (key === 'L' && U === 0)) ? 1 : 3) : 0;
              }
              if (direction === 1) {
                ZX = [0, 2].includes(index) ? (((key === 'U' && L === 1) || (key === 'R' && U === 1) || (key === 'D' && L === 3) || (key === 'L' && U === 3)) ? 1 : 3) : 0;
                ZR = [1, 3].includes(index) ? (((key === 'U' && L === 0) || (key === 'R' && U === 0) || (key === 'D' && L === 2) || (key === 'L' && U === 2)) ? 1 : 3) : 0;
              }
              if (direction === 3) {
                ZX = [0, 2].includes(index) ? (((key === 'U' && L === 3) || (key === 'R' && U === 3) || (key === 'D' && L === 1) || (key === 'L' && U === 1)) ? 1 : 3) : 0;
                ZR = [1, 3].includes(index) ? (((key === 'U' && L === 2) || (key === 'R' && U === 2) || (key === 'D' && L === 0) || (key === 'L' && U === 0)) ? 1 : 3) : 0;
              }
              if (direction === 4) {
                ZR = [0, 2].includes(index) ? (((key === 'U' && L === 3) || (key === 'R' && U === 3) || (key === 'D' && L === 1) || (key === 'L' && U === 1)) ? 1 : 3) : 0;
                ZY = [1, 3].includes(index) ? (((key === 'U' && L === 0) || (key === 'R' && U === 0) || (key === 'D' && L === 2) || (key === 'L' && U === 2)) ? 1 : 3) : 0;
              }
              if (direction === 5) {
                ZR = [0, 2].includes(index) ? (((key === 'U' && L === 1) || (key === 'R' && U === 1) || (key === 'D' && L === 3) || (key === 'L' && U === 3)) ? 1 : 3) : 0;
                ZY = [1, 3].includes(index) ? (((key === 'U' && L === 0) || (key === 'R' && U === 0) || (key === 'D' && L === 2) || (key === 'L' && U === 2)) ? 1 : 3) : 0;
              }

              rotateBlock(ZR, ZX, ZY);
            } else {
              slideBlock([
                [3, 4, 1, 5],
                [0, 4, 2, 5],
                [1, 5, 3, 4],
                [2, 5, 0, 4],
                [3, 2, 1, 0],
                [3, 0, 1, 2],
              ][direction][index]);
            }
            output();
            break;
          case 'KeyZ':
          case 'KeyX':
          case 'KeyC':
          case 'KeyA':
          case 'KeyS':
          case 'KeyD':
            rotateBlock(...keyMap[event.code]);
            output();
            break;
          case 'Space':
            if (phase === 'fall' && animationSwitch) {
              if (animation) clearTimeout(animation);
              pushDownBlock();
              nextTime = time;
              animate();
            }
            break;
          default:
        }
      };

      document.onkeyup = (event) => {
        switch (event.code) {
          case 'ShiftLeft':
          case 'ShiftRight':
            rotationSwitch = false;
            break;
        }
      };

      if (typeof display.ontouchstart === 'object') {
        display.ontouchstart = displayOnpointerdown;
      } else {
        display.onpointerdown = displayOnpointerdown;
      }
      if (typeof document.ontouchmove === 'object') {
        document.ontouchmove = documentMousemove;
      } else {
        document.onmousemove = documentMousemove;
      }
      
      const meterElements = ['focal-length', 'color-alpha'].reduce((elements, meterType) => ({
        ...elements, [meterType]: {
          meter: document.getElementById(`${meterType}-meter`),
          handle: document.getElementById(`${meterType}-meter-handle`),
          announcer: document.getElementById(`${meterType}-announcer`),
        },
      }), {});

      const getMeterParams = (meterType) => {
        const meterRect = meterElements[meterType].meter.getBoundingClientRect();
        const meterHandleRect = meterElements[meterType].handle.getBoundingClientRect();

        return {
          left: meterRect.left + meterHandleRect.width / 2,
          right: meterRect.left + meterRect.width - meterHandleRect.width / 2,
        };
      };

      const setMeterPosition = (meterType, percentage) => {
        const { left, right } = getMeterParams(meterType);
        meterElements[meterType].handle.style.left = `${Math.floor((right - left) * percentage)}px`;
      };

      const setMeterSwitch = (operate, clientX) => {
        meterSwitch = operate;
        if (operate === false) return;
        const meterHandleRect = meterElements[operate].handle.getBoundingClientRect();
        if (clientX >= meterHandleRect.left && clientX <= meterHandleRect.left + meterHandleRect.width) {
          meterHandleDiffX = clientX - (meterHandleRect.left + meterHandleRect.width / 2);
        } else {
          meterHandleDiffX = 0;
          setMeterLength(operate, clientX);
        }
      };

      const setMeterPercentage = (meterType, percentage) => {
        if (percentage < 0) percentage = 0;
        if (percentage > 1) percentage = 1;
        percentage = Math.floor(percentage * 100) / 100;
        setMeterPosition(meterType, percentage);
        switch (meterType) {
          case 'focal-length':
            focalLengthPercentage = 1 + 2 * percentage;
            meterElements[meterType].announcer.innerText = Math.round(focalLengthPercentage * 10000) / 100;
            break;
          case 'color-alpha':
            colorAlpha1 = 100 + Math.round(155 * percentage);
            colorAlpha2 = 139 + Math.round(116 * percentage);
            meterElements[meterType].announcer.innerText = Math.round(colorAlpha1 / 255 * 100);
            break;
          default:
        }
        output();
      };

      const setMeterLength = (meterType, clientX) => {
        const { left, right } = getMeterParams(meterType);
        const percentage = (clientX - meterHandleDiffX - left) / (right - left);
        setMeterPercentage(meterType, percentage);
      };

      Object.keys(meterElements).forEach((meterKey) => {
        meterElements[meterKey].meter.onpointerdown = (event) => {
          setMeterSwitch(meterKey, getClientPosition(event).X);
        };
      });

      const setColorMode = (operate) => {
        colorMode = operate;
        output();
      };

      colorModeInput1.onchange = (event) => {
        setColorMode(event.target.checked ? 'agate' : 'normal');
      };

      colorModeInput2.onchange = (event) => {
        setColorMode(event.target.checked ? 'normal' : 'agate');
      };

      setMeterPosition('focal-length', (focalLengthPercentage - 1) / 2);
      setMeterPosition('color-alpha', (colorAlpha1 - 100) / 155);
      meterElements['focal-length'].announcer.innerText = Math.round(focalLengthPercentage * 10000) / 100;
      meterElements['color-alpha'].announcer.innerText = Math.round(colorAlpha1 / 255 * 100);
      startAnimation();
    </script>
  </body>
</html>
